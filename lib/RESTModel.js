var _                   = require('lodash'),
	Express             = require('express'),
	Helpers             = require('./helpers/Helpers'),
	DefaultScaffolding  = require('./DefaultScaffolding'),
	AssociationModel     = require('./AssociationModel'),
	QueryHelper         = require('./helpers/QueryHelpers');

module.exports = (function() {

	/**
	 * Sleep Object that holds a sequelize model's RESTful bindings.
	 *
	 * Can also contain this model's associations.
	 *
	 * @param {Sleep} API that this belongs to.
	 * @param modelDefinition
	 * @constructor
	 */
	var RestModel = function(api, modelDefinition) {
		this.parentAPI = api;
		this.childModels = [];

		this.initialized = false;

		this.model = modelDefinition.model;
		this.path = this.model.tableName.toLowerCase();
		this.modelRouter = Express.Router();
		this.primaryKey = Helpers.getPrimaryKey(this.model);

		/**
		 * Array of valid columns in the class minus the primary key
		 * However the primary key is only 'not valid' to be set if it is
		 * marked as auto-generated.
		 */
		this.validColumns = _.keys(this.model.rawAttributes);

		if(this.model.rawAttributes[this.primaryKey]._autoGenerated)
			this.validColumns.splice(this.validColumns.indexOf(this.primaryKey), 1);

		this._initializeOptions(modelDefinition);
		this._initializeAssociationOptions(modelDefinition);
		this._initializeRoutes(modelDefinition);

		this.filter = Helpers.mergeTriplicate({
			// If this is filled out, don't allow these parameters to be used.
			blacklist: [],

			// If this is filled out, ONLY allow these parameters to be used.
			whitelist: [],

			// Include these fields in output
			include: [],

			// Exclude these fields from output
			exclude: []
		}, this.model.filter || {}, modelDefinition.filter || {});
	};

	RestModel.prototype._initializeOptions = function(mDefinition) {
		this.options = Helpers.mergeObjects({
			// Should we automatically generate the association sub-routes?
			walk_associations: true,

			// How deep into the association tree should we walk?
			walk_depth: 1,

			// Should we allow the base GET /<MODEL_PATH> to retrieve all of something?
			allow_root: true,

			// Enables or disables the default routes for this model.
			// Disabling a route here makes it inaccessible even if you
			// have it accessible through an authentication middleware.
			defaults: {
				param: true,
				get: true,
				post: true,
				put: true,
				patch: true,
				delete: true
			}
		}, mDefinition.options || {});
	};

	/**
	 * Gets the association options for the named association, this only works for top-level
	 * associations, not nested associations; however nested associations should be stored within
	 * their 'parent' association options in the same fashion as top-level associations would be,
	 * that being; by their 'path'.
	 *
	 * @param forName
	 * @returns {*}
	 */
	RestModel.prototype.getAssociationOptions = function(forName) {
		if(!this.associationOptions) return undefined;
		return this.associationOptions.hasOwnProperty(forName) && this.associationOptions[forName];
	};

	/**
	 * Pulls the external association options into the RESTModel, these are
	 * chopped up and nested appropriately into each level of the association
	 * tree.
	 *
	 * @param mDefinition
	 * @private
	 */
	RestModel.prototype._initializeAssociationOptions = function(mDefinition) {
		if(mDefinition.associationOptions)
			this.associationOptions = mDefinition.associationOptions;
	};

	RestModel.prototype._initializeRoutes = function(mDefinition) {
		/**
		 * Extra route options, to add convenience functions to a
		 * route for commonly used shorthands.
		 *
		 * However this also contains the default routes as well.
		 */
		this.routes = {};

		var opt = this.options.defaults;

		this.routes.param = opt.param ? [
			DefaultScaffolding.primaryKeyParameter
		] : [];

		this.routes.get = opt.get ? [
			DefaultScaffolding.getByPrimaryKey
		] : [];

		if(this.options.allow_root)
			this.routes.get.unshift(DefaultScaffolding.getRoot);

		this.routes.post = opt.post ? [
			DefaultScaffolding.createNew
		] : [];

		this.routes.put = opt.put ? [
			DefaultScaffolding.updateRow
		] : [];

		this.routes.patch = opt.patch ? [
			// For the time being this does the exact same thing as the put,
			// as I honestly don't grasp the difference between these two.
			DefaultScaffolding.updateRow
		] : [];

		this.routes.delete = opt.delete ? [
			DefaultScaffolding.deleteWhere,
			DefaultScaffolding.deleteByPrimaryKey
		] : [];

		/**
		 * Merge together the routes path definitions for our routes.
		 *
		 * The external routes are added to the front of the arrays, as to
		 * allow them to intercept a router before it can be passed to later
		 * definitions.
		 *
		 * Precedence of routes added
		 *
		 * Default < Model Routes < Custom Routes
		 */
		Helpers.mergeTriplicate(this.routes, this.model.routes || {}, mDefinition.routes || {});
	};

	/**
	 * Pushes a new scaffolding to the route specified by the verb.
	 *
	 * @param verb
	 * @param scaffold
	 * @returns {*|Number}
	 */
	RestModel.prototype.pushHeadRoute = function(verb, scaffold) {
		if(this.initialized)
			throw new Error("Cannot push new scaffolding into bound rest model " + this.path);
		else return this.routes[verb].unshift(scaffold);
	};

	/**
	 * Binds this REST Model to the specified express router, using the
	 * table's name under-cased as the path extension.
	 *
	 * TODO: Error handling if something goes wrong in one of the sub-routes
	 *
	 * @param {Express.Router} The router for this Model to be bound to.
	 */
	RestModel.prototype.bindModel = function(rt) {
		var api = this.parentAPI;
		var mr = this.modelRouter;
		var tp = this;
		var model = tp.model;
		var depth = this.options.walk_depth;
		var children = this.childModels;


		if(this.options.walk_associations && this.options.walk_depth > 0)
		{
			var hmAssociations = Helpers.getHasManyAssociations(this);

			_.forEach(hmAssociations, function(value) {
				var asModel = new AssociationModel(api, tp, { model: value }, depth);
				asModel.bindModel();
				children.unshift(asModel);
			});
		}

		_.forEach(tp.routes, function(value, key) {
			_.forEach(tp.routes[key], function(scaffold) {
				var rt = scaffold;

				if(_.isFunction(scaffold))
					rt = scaffold(tp);

				if(rt.hasOwnProperty('auth'))
					mr[key](rt.path, rt.auth, rt.callback);
				else
					mr[key](rt.path, rt.callback);
			});
		});

		rt.use('/' + this.path, this.modelRouter);
		this.initialized = true;
	};

	return RestModel;
})();