var _                   = require('lodash'),
	Express             = require('express'),
	Helpers             = require('./helpers/Helpers'),
	DefaultScaffolding  = require('./DefaultScaffolding'),
	AssociationModel     = require('./AssociationModel'),
	QueryHelper         = require('./helpers/QueryHelpers');

module.exports = (function() {

	/**
	 * Sleep Object that holds a sequelize model's RESTful bindings.
	 *
	 * Can also contain this model's associations.
	 *
	 * @param {Sleep} API that this belongs to.
	 * @param modelDefinition
	 * @constructor
	 */
	var RestModel = function(api, modelDefinition) {
		this.parentAPI = api;
		this.childModels = [];

		this.initialized = false;

		this.model = modelDefinition.model;
		this.path = this.model.tableName.toLowerCase();
		this.modelRouter = Express.Router();
		this.primaryKey = Helpers.getPrimaryKey(this.model);

		/**
		 * Array of valid columns in the class minus the primary key
		 * However the primary key is only 'not valid' to be set if it is
		 * marked as auto-generated.
		 */
		this.validColumns = _.keys(this.model.rawAttributes);

		if(this.model.rawAttributes[this.primaryKey]._autoGenerated)
			this.validColumns.splice(this.validColumns.indexOf(this.primaryKey), 1);

		this.options = _.merge({
			// Should we automatically generate the association sub-routes?
			walk_associations: true,

			// How deep into the association tree should we walk?
			walk_depth: 1,

			// Should we allow the base GET /<MODEL_PATH> to retrieve all of something?
			allow_root: true,

			// Enables or disables the default routes for this model.
			// Disabling a route here makes it inaccessible even if you
			// have it accessible through an authentication middleware.
			defaults: {
				param: true,
				get: true,
				post: true,
				put: true,
				patch: true,
				delete: true
			}
		}, modelDefinition.options || {}, Helpers.ldArrayMerge);


		/**
		 * Extra route options, to add convenience functions to a
		 * route for commonly used shorthands.
		 *
		 * However this also contains the default routes as well.
		 */
		this.routes = {};

		var opt = this.options.defaults;

		this.routes.param = opt.param ? [
			DefaultScaffolding.primaryKeyParameter(this)
		] : [];

		this.routes.get = opt.get ? [
			DefaultScaffolding.getByPrimaryKey(this)
		] : [];

		this.routes.post = opt.post ? [
			DefaultScaffolding.createNew(this)
		] : [];

		this.routes.put = opt.put ? [
			DefaultScaffolding.updateRow(this)
		] : [];

		this.routes.patch = opt.patch ? [
			// For the time being this does the exact same thing as the put,
			// as I honestly don't grasp the difference between these two.
			DefaultScaffolding.updateRow(this)
		] : [];

		this.routes.delete = opt.delete ? [
			DefaultScaffolding.deleteWhere(this),
			DefaultScaffolding.deleteByPrimaryKey(this)
		] : [];


		/**
		 * Merge together the routes path definitions for our routes.
		 *
		 * The external routes are added to the front of the arrays, as to
		 * allow them to intercept a router before it can be passed to later
		 * definitions.
		 */
		_.merge(this.routes, modelDefinition.routes || {}, Helpers.ldArrayMerge);


		this.filter = _.merge({
			// If this is filled out, don't allow these parameters to be used.
			blacklist: [],

			// If this is filled out, ONLY allow these parameters to be used.
			whitelist: [],

			// Only output these fields, sneaky sneaky.
			fields: []
		}, modelDefinition.options && modelDefinition.options.filter || {}, Helpers.ldArrayMerge);
	};

	/**
	 * Pushes a new scaffolding to the route specified by the
	 *
	 * @param verb
	 * @param scaffold
	 * @returns {*|Number}
	 */
	RestModel.prototype.pushHead = function(verb, scaffold) {
		if(this.initialized)
			throw new Error("Cannot push new scaffolding into bound rest model " + this.path);
		else return this.routes[verb].unshift(scaffold);
	};

	/**
	 * Binds this REST Model to the specified express router, using the
	 * table's name under-cased as the path extension.
	 *
	 * @param {Express.Router} The router for this Model to be bound to.
	 */
	RestModel.prototype.bindModel = function(rt) {
		var api = this.parentAPI;
		var mr = this.modelRouter;
		var tp = this;
		var model = tp.model;
		var depth = this.options.walk_depth;
		var children = this.childModels;


		if(this.options.walk_associations)
		{
			var hmAssociations = Helpers.getHasManyAssociations(this);

			_.forEach(hmAssociations, function(value, key) {
				var asModel = new AssociationModel(api, tp, { model: value }, depth);
				asModel.bindModel();

				children.unshift(asModel);
			});
		}

		_.forEach(tp.routes, function(value, key) {
			_.forEach(tp.routes[key], function(scaffold) {
				var rt = scaffold;

				if(_.isFunction(scaffold))
					rt = scaffold(tp);

				if(rt.hasOwnProperty('auth'))
					mr[key](rt.path, rt.auth, rt.callback);
				else
					mr[key](rt.path, rt.callback);
			});
		});

		if(this.options.allow_root)
		{
			mr.get('/', function(req, res) {
				model.findAll(QueryHelper.buildQueryParameters(tp, req)).success(function(objs) {
					res.status(200).json(objs);
				}).error(function(err) {
					res.status(404).json(err);
				})
			});
		}

		rt.use('/' + this.path, this.modelRouter);
		this.initialized = true;
	};

	return RestModel;
})();