var _                       = require('lodash'),
	util                    = require('util'),
	Express                 = require('express'),
	Helpers                 = require('./helpers/Helpers');

module.exports = (function() {

	/**
	 * Sleep Object that holds a sequelize model's RESTful bindings.
	 *
	 * Can also contain this model's associations.
	 *
	 * TODO: Implement Filters
	 *
	 * @param {Sleep} API that this belongs to.
	 * @param modelDefinition
	 * @constructor
	 */
	var AssociationModel = function(api, parent, modelDefinition, remainingDepth) {
		this.parentAPI = api;
		this.RESTParent = parent;
		this.childModels = [];

		this.remainingDepth = remainingDepth - 1;

		this.model = modelDefinition.model;
		this.modelRouter = Express.Router();

		this.path = this.model.tableName.toLowerCase();
		this.primaryKey = Helpers.getPrimaryKey(this.model);
		this.associatedBy = Helpers.getAssociatedBy(this.RESTParent, this.model);

		this._initializeOptions(modelDefinition);
		this._initializeRoutes(modelDefinition);

		/**
		 * Array of valid columns in the class minus the primary key
		 * However the primary key is only 'not valid' to be set if it is
		 * marked as auto-generated.
		 */
		this.validColumns = _.keys(this.model.rawAttributes);

		if(this.model.rawAttributes[this.primaryKey]._autoGenerated)
			this.validColumns.splice(this.validColumns.indexOf(this.primaryKey), 1);
	};

	AssociationModel.prototype.getAssociationOptions = function(forName) {
		if(!this.options) return undefined;
		return this.options.hasOwnProperty(forName) && this.options[forName];
	};

	/**
	 * Loads the options for this model from its Sequelize model and then its
	 * parent's association options, manually passed association options will
	 * ALWAYS override those that are specified in the Sequelize model.
	 *
	 * @param modelDefinition
	 * @private
	 */
	AssociationModel.prototype._initializeOptions = function(modelDefinition) {
		var defaultOptions = {
			inheritRoutes: true
		};

		this.options = Helpers.mergeTriplicate(defaultOptions,
			this.RESTParent.getAssociationOptions(this.path),
			this.model.associationOptions || {});

		this.filter = Helpers.mergeTriplicate(
			{
				blacklist: [],
				whitelist: [],
				include: [],
				exclude: []
			},
			this.options.filter || {},
			this.model.filter || {}
		);
	};

	AssociationModel.prototype._initializeRoutes = function(modelDefinition) {
		this.routes = {};

		if(this.model.routes)
			this.routes = Helpers.mergeObjects(this.routes, this.model.routes);

		if(this.options.inheritRoutes)
		{
			this.routes = Helpers.mergeObjects(this.routes, this.RESTParent.routes);
		}
	};

	AssociationModel.prototype.bindModel = function() {
		var tp = this;
		var api = this.parentAPI;
		var mr = this.modelRouter;
		var pmr = this.RESTParent.modelRouter;
		var children = this.childModels;
		var remainingDepth = this.remainingDepth;


		if(remainingDepth > 0)
		{
			var hmAssociations = Helpers.getHasManyAssociations(this);

			_.forEach(hmAssociations, function(value) {
				var asModel = new AssociationModel(api, tp, { model: value }, remainingDepth);
				asModel.bindModel();
				children.unshift(asModel);
			});
		}

		_.forEach(tp.routes, function(value, key) {
			_.forEach(tp.routes[key], function(scaffold) {
				var rt = scaffold;

				if(_.isFunction(scaffold))
					rt = scaffold(tp);

				if(rt.hasOwnProperty('auth'))
					mr[key](rt.path, rt.auth, rt.callback);
				else
					mr[key](rt.path, rt.callback);
			});
		});

		pmr.use(util.format('/:%s/%s', Helpers.getIdentifier(this.RESTParent), this.path), this.modelRouter);
	};

	return AssociationModel;
})();